<a name="Intro"></a>
<h1>Introduction</h1>

<h3> Stokes Problem </h3>

The purpose of this tutorial is to compare linear solvers and to ultimately find better linear solvers than we had.  We see that the linear solvers used in Step-22 cannot keep up with FGMRES using geometric multigrid as a precondtioner for the velocity block, since multigrid is the only way to get $O(n)$ solve time. Using the Timer class, we collect some statistics that compare setup times, solve times, number of iterations, and computing errors to make sure that what we have implemented is correct.

This program deals with the Stokes system of equations which reads as follows in non-dimensionalized form:

@f{eqnarray*}
  - \Delta u + \nabla p & =& f \\
 - \nabla \cdot u &=& 0 
@f}

Note that we are using the deformation tensor instead of $\Delta u$ (a detailed desription of the difference between the two can be found in Step-22, but in summary, the deformation tensor is more physical as well as more expensive.)

Note that we also have the following conditions on our problem:
@f{eqnarray*}
  \nabla \cdot u & =& 0 \\
 \int_\Omega p &=& 0 
@f}

<h3> Differences from Step-22 </h3>
The main difference is that here we use block solvers instead of the Schur Complement approach used in step-22. Details of this approach can be found under the Block Schur complement preconditioner subsection of the Possible Extensions section of Step-22. Since we act on the whole block system now, we have to live with the disadvantage that we need to perform the solver iterations on the whole block system. There you will find not only a description of what it is doing but also the code you can use.  That being said, we use an approach slightly different from what is used there.  

For the preconditioner of the velocity block, we borrow a class from ASPECT called BlockSchurPreconditioner that does the same thing but in a more efficient way for our purposes.  The major difference is that it does not use a smart pointer or InverseMatrix, as well as having the option to solve for the inverse of A or just apply one preconditioner sweep for it instead.

<h3> Linear solver and preconditioning issues </h3>
The weak form of the discrete equations naturally leads to the following linear system for the nodal values of the velocity and pressure fields: 
@f{eqnarray*} 
\left(\begin{array}{cc} A & B^T \\ B & 0 \end{array}\right) \left(\begin{array}{c} U \\ P \end{array}\right) = \left(\begin{array}{c} F \\ 0 \end{array}\right),
@f}

Our alternative to the way Step-22 solved the problem is to attack the block system at once and use an approximate Schur complement as efficient preconditioner. The idea is as follows: if we find a block preconditioner $P$ such that the matrix 
@f{eqnarray*}
\left(\begin{array}{cc} A & B^T \\ B & 0 \end{array}\right)  P^{-1}
@f}

is simple, then an iterative solver with that preconditioner will converge in a few iterations. Notice that we are doing right preconditioning for this.  Using the Schur complement $S=BA^{-1}BT$, one finds that

@f{eqnarray*}
 P^{-1} = \left(\begin{array}{cc} \hat{A} & B^T \\ 0 & \hat{S} \end{array}\right)^{-1} 
@f}

is a good choice, where $M_p=\hat{S} \approx S$, $M_p$ is the mass matrix, and $\hat{A}$ is an approximation of A that has the enum to decide how you want to solve for it. Note that instead of $Mx=b$, we solve 

@f{eqnarray*}
MP^{-1}y &=& b\\
x &=& P^{-1} y\\
@f}

where FGMRES is used because when it solves the first equation, it remembers $P^{-1}$ and uses it again in the second equation.

It is important to note that
@f{eqnarray*}
 P = \left(\begin{array}{cc} A^{-1} & 0 \\ 0 & I \end{array}\right) \left(\begin{array}{cc} I & B^T \\ 0 & -I \end{array}\right) \left(\begin{array}{cc} I & 0 \\ 0 & S^{-1} \end{array}\right)
@f}

Since $P$ is aimed to be a preconditioner only, we shall use approximations to the inverse of the Schur complement $S$ and the matrix $A$. Hence, the Schur complement will be approximated by the pressure mass matrix $M_p$, whereas we use multiple methods for approximating $A$.  These approximations only have to be "good enough" and are actually solved with relatively small precision.

<h3> Linear Solvers </h3>
The main solver this tutorial showcases is using FGMRES for an outside solver, but we also have two inner solves.  The first of which is the inner solve for $S$ which is approximated by the nagative of a mass matrix $-M_p$ and is solved by using CG + ILU, whereas for the inside solver for $A$ we will use multiple approaches: CG + ILU, just ILU, CG + GMG, or just GMG.   

Instead of FGMRES, we also use the direct solver UMFPACK to compare ourr results to.  If you want to use UMFPACK as a solver, it is important to note that you have a singular system since the integral of mean pressure being equal to zero not implemented.  So, to deal with this, we set the first pressure node equal to zero.

<h3> Reference Solution </h3>

The domain, right hand side and boundary conditions we implement are chosen because they are simple and they will allow us to compute errors using a reference solutions.  We model this situation by solving the following set of equations and boundary conditions on the domain Ω=[0,1]×[0,1]×[0,1]: 

For this section, let $u_{x}$ be the derivative of $u$ with respect to $x$, $u_{xx}$ be the second derivative of $u$ with respect to $x$, etc.  Note that the boundary indicators and geometry used in Step-22 are different for this tutorial, as we have the same boundary conditions everwhere on the unit cell.  To enforce the boundary conditions we can just use our reference solution that we will now define.

Let $u=(u_1,u_2,u_3)=(2\sin (\pi x), - \pi y \cos (\pi x),- \pi z \cos (\pi x))$ and $p = \sin (\pi x)\cos (\pi y)\sin (\pi z)$.

If you look up in the deal.ii manual what is needed to create a class inherited from <code>Function@<dim@></code>, you will find not only a value function, but vector_value, value_list, etc.  Different things you use in your code will require one of these particular functions. This can be confusing at first, but luckily the only thing you actually need to implement is value.  The other ones have default implementations inside deal.ii and will be called on their own as long as you implement value correctly.

Notice that for our reference solution we had to enforce that the divergence of $u$ is zero. In addition, we need to make sure our pressure has mean zero.

We need to find $\bf f$ such that:

@f{align*}
{\bf f} =  - \Delta u + \nabla p 
@f}

and this is equivalently written as:

@f{align}
{\bf f} =  -\left( u_{1xx} + u_{1yy} + u_{1zz},u_{2xx} + u_{2yy} + u_{2zz},u_{3xx} + u_{3yy} + u_{3zz} \right) + (p_x,p_y,p_z)
@f}

Now, consider the following:

@f{eqnarray*}
u_{1xx} &=& -2 \pi^2 \sin (\pi x)\\
u_{2xx} &=& \pi^3 y \cos(\pi x)\\
u_{3xx} &=& \pi^3 z \cos(\pi x)\\
u_{1yy} &=& u_{1zz} = u_{2yy} = u_{2zz} = u_{3yy} = u_{3zz} = 0\\
p_x &=& \pi \cos(\pi x) \cos(\pi y) \sin(\pi z) \\
p_y &=& - \pi \sin(\pi y) \sin(\pi x) \sin(\pi z) \\
p_z &=& \pi \cos(\pi z) \sin(\pi x) \cos(\pi y) \\ 
@f}

and thus

@f{eqnarray*}
{\bf f} &=& -(-2 \pi^2 \sin (\pi x),\pi^3 y \cos(\pi x),\pi^3 z \cos(\pi x))\\
& & + (\pi \cos(\pi x) \cos(\pi y) \sin(\pi z) ,- \pi \sin(\pi y) \sin(\pi x) \sin(\pi z),  \pi \cos(\pi z) \sin(\pi x) \cos(\pi y)) \\
 &=& (2 \pi^2 \sin (\pi x),- \pi^3 y \cos(\pi x),- \pi^3 z \cos(\pi x))\\
& & + (\pi \cos(\pi x) \cos(\pi y) \sin(\pi z) ,- \pi \sin(\pi y) \sin(\pi x) \sin(\pi z),  \pi \cos(\pi z) \sin(\pi x) \cos(\pi y))
@f}

<h3> Computing Errors </h3>
We need to make sure our mean pressure is zero.  To do this we use the <code>compute_mean_value</code> function in deal.ii to compute the mean value of pressure component of the solution. 

<h3> DoF Handlers </h3>
Geometric multigrid needs to know about the finite element system for the velocity but this is now part of the entire system which is hard to access.  The reason for this is that there is currently no way in deal.ii to say "I want just part of a DoF handler" so in order to do this we create a new one and assure they have same ordering so that you can copy over one to the other.  In other words we want: u (velocity dof handler) = solution.block(0) (from system DofHandler)